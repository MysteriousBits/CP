\chapter{Number Theory}

\section{Mod Template}
\begin{lstlisting}[language=C++]
ll mod(ll n)
{
    n %= MOD;
    return n < 0 ? MOD + n : n;
}

ll modpow(ll n, ll k)
{
    ll ret = 1;

    while (k)
    {
        if (k & 1) ret = (ret * n) % MOD;
        n = (n * n) % MOD;
        k >>= 1;
    }

    return ret;
}

inline ll inv(ll n)
{
    return modpow(n, MOD - 2);
}

inline ll mul(ll x, ll y)
{
    return ((x % MOD) * (y % MOD)) % MOD;
}

inline ll dvd(ll x, ll y)
{
    return mul(x, inv(y));
}
\end{lstlisting}
\sectionend

\section{Binomial Coeffecient}
\begin{lstlisting}[language=C++]
ll fact[MAXN];

void calc_fact()
{
    fact[0] = 1;
    for (int i = 1; i < MAXN; ++i)
    {
        fact[i] = (fact[i - 1] * i) % MOD;
    }
}

ll C(int n, int k)
{
    if (k > n) return 0;
    return (1LL * fact[n] *
        inv((1LL * fact[k] * fact[n - k]) % MOD)) % MOD;
}
\end{lstlisting}
\sectionend

\section{Sieve}
\begin{lstlisting}[language=C++]
VI primes;
bool isprime[MAXN];

void sieve()
{
    isprime[1] = false;
    for (int i = 2; i < MAXN; ++i) isprime[i] = true;

    for (int i = 2; i < MAXN; ++i)
    {
        if (!isprime[i]) continue;
        primes.pb(i);

        if (1LL * i * i >= MAXN) continue;
        for (int j = i * i; j < MAXN; j += i)
            isprime[j] = false;

    }
}
\end{lstlisting}
\sectionend

\section{CRT}
\begin{lstlisting}[language=C++]
int extended_gcd(ll a, ll b, ll& x, ll& y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }

    ll g = extended_gcd(b, a % b, x, y);
    swap(x, y);
    y -= x * (a / b);
    return g;
}

ll modinv(ll a, ll m)
{
    ll x, y;
    extended_gcd(a, m, x, y);

    x %= m;
    return x < 0 ? x + m : x;
}

ll crt(vector<pair<ll, ll>>& mods)
{
    ll mod = 1;
    for (auto& p : mods) mod *= p.ss;

    ll ans = 0;
    for (auto [x, p] : mods)
    {
        ll m = mod / p;
        m = (m * modinv(m, p)) % mod;
        m = (m * x) % mod;

        ans = (ans + m) % mod;
    }

    return ans;
}
\end{lstlisting}
\sectionend