\chapter{Graph}

\section{Dijkstra}
\begin{lstlisting}[language=C++]
struct Node
{
    int u;
    ll dist;

    bool operator< (const Node& v) const
    {
        return dist > v.dist;
    }
};

void dijkstra(int start, vector<ll>& dis, vector<VPI>& adj)
{
    priority_queue<Node> q;
    dis[start] = 0;
    q.push({start, 0});

    while (!q.empty())
    {
        Node node = q.top();
        int u = node.u;
        q.pop();

        if (dis[u] < node.dist) continue;

        for (auto e : adj[u])
        {
            if (node.dist + e.ss < dis[e.ff])
            {
                dis[e.ff] = node.dist + e.ss;
                q.push({e.ff, dis[e.ff]});
            }
        }
    }
}
\end{lstlisting}
\sectionend

\section{LCA}
\begin{lstlisting}[language=C++]
int k;
VVI tree;
int step = 0;
VI vis_start, vis_end;
VVI st;

void build_st(int u, int p)
{
    st[u][0] = p;
    for (int i = 1; i <= k; ++i)
        st[u][i] = st[st[u][i - 1]][i - 1];
}

void dfs(int u, int p)
{
    vis_start[u] = step++;
    build_st(u, p);

    for (auto v : tree[u])
    {
        if (v != p) dfs(v, u);
    }

    vis_end[u] = step++;
}

bool is_ancestor(int a, int b)
{
    return vis_start[a] < vis_start[b] && vis_end[a] > vis_end[b];
}

int lca(int a, int b)
{
    if (a == b) return a;
    if (is_ancestor(a, b)) return a;
    if (is_ancestor(b, a)) return b;

    for (int i = k; i >= 0; --i)
    {
        if (!is_ancestor(st[a][i], b)) a = st[a][i];
    }

    return st[a][0];
}

void init(int n)
{
    vis_start.assign(n + 1, 0);
    vis_end.assign(n + 1, 0);

    k = __lg(2 * n - 1);
    st.assign(n + 1, VI(k + 1));
    dfs(1, 1);
}
\end{lstlisting}
\sectionend

\section{HLD}
\begin{lstlisting}[language=C++]

VI heavy, chain, label, par, sz, dep;
int timer;

void dfsz(int u, int p, VVI& tree)
{
    sz[u] = 1;
    par[u] = p;
    dep[u] = dep[p] + 1;

    int mx = -1;
    for (int v : tree[u])
    {
        if (v == p) continue;

        dfsz(v, u, tree);
        sz[u] += sz[v];
        if (sz[v] > mx) mx = sz[v], heavy[u] = v;
    }
}

void dfshld(int u, int p, VVI& tree, int head)
{
    label[u] = timer++;
    chain[u] = head;

    if (heavy[u] != -1) dfshld(heavy[u], u, tree, head);

    for (int v : tree[u])
    {
        if (v == p || v == heavy[u]) continue;

        dfshld(v, u, tree, v);
    }
}

void inithld(int n, VVI& tree)
{
    heavy = VI(n + 1, -1);
    chain = VI(n + 1);
    label = VI(n + 1);
    sz = VI(n + 1);
    par = VI(n + 1);
    dep = VI(n + 1);

    timer = 1;
    dfsz(1, 0, tree);
    dfshld(1, 0, tree, 1);
}

int qryup(int u, int v)
{
    if (dep[u] < dep[v]) swap(u, v);

    int head = chain[u];
    int ret = 0; // init value
    while (dep[head] > dep[v])
    {
        // ret = ...(label[head], label[u]);
        u = par[head];
        head = chain[u];
    }

    // ret = ...(label[v], label[u]);
    return ret;
}
\end{lstlisting}
\sectionend

\section{SCC}
\begin{lstlisting}[language=C++]
VVI scc;
VI stk;
int disc[MAXN], low[MAXN];
bool instk[MAXN];
int cur_time;

void dfs_scc(int u, VVI& g)
{
    disc[u] = low[u] = ++cur_time;
    instk[u] = true;
    stk.pb(u);

    for (int v : g[u])
    {
        if (!disc[v])
        {
            dfs_scc(v, g);
            low[u] = min(low[u], low[v]);
        }
        else if (instk[v])
            low[u] = min(low[u], disc[v]);
    }

    if (low[u] < disc[u]) return;

    scc.pb(VI());
    bool rem = true;
    while (rem)
    {
        int v = stk.back();
        stk.pop_back();
        instk[v] = false;
        scc.back().pb(v);
        rem = v != u;
    }
}

void tarjan(VVI& g)
{
    cur_time = 0;
    int n = g.size();

    for (int i = 0; i < n; ++i) disc[i] = 0;
    for (int u = 1; u < n; ++u) if (!disc[u]) dfs_scc(u, g);
}
\end{lstlisting}
\sectionend